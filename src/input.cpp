#include "input.h"

#if ENABLE_MEDIAN_FILTER
RunningMedian rmSamples[5]
	= {RunningMedian(MEDIAN_SAMPLES),
	   RunningMedian(MEDIAN_SAMPLES),
	   RunningMedian(MEDIAN_SAMPLES),
	   RunningMedian(MEDIAN_SAMPLES),
	   RunningMedian(MEDIAN_SAMPLES)};
#endif

int maxFingers[5] = {0, 0, 0, 0, 0};
int minFingers[5] = {ANALOG_MAX, ANALOG_MAX, ANALOG_MAX, ANALOG_MAX, ANALOG_MAX};
int* GloversInput::getFingerPosition(bool calibrating, bool reset) {
	int rawFingers[5] = {0, 0, 0, 0, 0};

	int ADC_Value = analogRead(PIN_ADC);
	for (size_t i = 0; i < 5; i++) {
		setChannel(i);
		delayMicroseconds(MULTIPLEXER_DELAY);  // 等待模拟输入稳定
		ADC_Value = analogRead(PIN_ADC) - PHASE;
		rawFingers[i] = ADC_Value < 0 ? 0 : ADC_Value;
	}
// 反转
#if FLIP_POTS
	for (int i = 0; i < 5; i++) {
		rawFingers[i] = ANALOG_MAX - rawFingers[i];
	}
#endif

#if ENABLE_MEDIAN_FILTER
	for (int i = 0; i < 5; i++) {
		rmSamples[i].add(rawFingers[i]);
		rawFingers[i] = rmSamples[i].getMedian();
	}
#endif

	// 重置最大值和最小值
	if (reset) {
		for (int i = 0; i < 5; i++) {
			maxFingers[i] = 0;
			minFingers[i] = ANALOG_MAX;
		}
	}

	if (calibrating) {
		for (int i = 0; i < 5; i++) {
			if (rawFingers[i] > maxFingers[i])
#if CLAMP_FLEXION
				maxFingers[i]
					= (rawFingers[i] <= CLAMP_MAX) ? rawFingers[i] : CLAMP_MAX;
#else
				maxFingers[i] = rawFingers[i];
#endif
			if (rawFingers[i] < minFingers[i])
#if CLAMP_FLEXION
				minFingers[i]
					= (rawFingers[i] >= CLAMP_MIN) ? rawFingers[i] : CLAMP_MIN;
#else
				minFingers[i] = rawFingers[i];
#endif
		}
	}

	static int calibrated[5] = {511, 511, 511, 511, 511};

	for (int i = 0; i < 5; i++) {
		if (minFingers[i] != maxFingers[i]) {
			calibrated[i]
				= map(rawFingers[i], minFingers[i], maxFingers[i], 0, ANALOG_MAX);
#if CLAMP_ANALOG_MAP
			if (calibrated[i] < 0) {
				calibrated[i] = 0;
			}
			if (calibrated[i] > ANALOG_MAX) {
				calibrated[i] = ANALOG_MAX;
			}
#endif
		} else {
			calibrated[i] = ANALOG_MAX / 2;
		}
	}
	return calibrated;
}

void GloversInput::setChannel(int channel) {
	digitalWrite(PIN_SA, bitRead(channel, 0));
	digitalWrite(PIN_SB, bitRead(channel, 1));
	digitalWrite(PIN_SC, bitRead(channel, 2));
}

int GloversInput::analogReadDeadzone(byte pin){
  int raw = analogRead(pin);
  if (abs(ANALOG_MAX/2 - raw) < JOYSTICK_DEADZONE * ANALOG_MAX / 100)
    return ANALOG_MAX/2;
  else
    return raw;
}

int GloversInput::getJoyX(){
  #if JOYSTICK_BLANK
  return ANALOG_MAX/2;
  #elif JOY_FLIP_X
  return ANALOG_MAX - analogReadDeadzone(PIN_JOY_X);
  #else
  return analogReadDeadzone(PIN_JOYSTICK_X);
  #endif
}

int GloversInput::getJoyY(){
  #if JOYSTICK_BLANK
  return ANALOG_MAX/2;
  #elif JOY_FLIP_Y
  return ANALOG_MAX - analogReadDeadzone(PIN_JOY_Y);
  #else
  return analogReadDeadzone(PIN_JOYSTICK_Y);
  #endif
}